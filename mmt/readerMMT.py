import os.path
import sys
import numpy as np
import pandas as pd

sys.path.append(sys.path[0] + '/..')
from mmt.featureExtractor import calculateFeatures

"""
Functions responsible for reading a report generated by MMT-probe.

tls_event, tcp_event, etc are the predefined mmt-probe attributes that are taken from the packets using MMT-probe. Those values need
to be aligned with probe config file.

"""


tls_event = [
            "meta.direction",
            "ip.session_id",
            "ssl.tls_version",
            "ssl.tls_content_type",
            "ssl.tls_length",
            "ssl.ssl_handshake_type",
            ]

tcp_event = [
            "meta.direction", # if = 0 then its client -> server (Checked with syn=1 ack=0)
            "ip.session_id",
            "tcp.src_port",
            "tcp.dest_port",
            "tcp.payload_len",
            "tcp.fin",
            "tcp.syn",
            "tcp.rst",
            "tcp.psh",
            "tcp.ack",
            "tcp.urg",
            "tcp.tcp_session_payload_up_len",
            "tcp.tcp_session_payload_down_len"
            ]

ipv4_event = [
            "meta.direction", # if = 0 then its client -> server (Checked with syn=1 ack=0)
            "ip.session_id",
            "time",
            "ip.version",
            "ip.src",
            "ip.dst",
            "ip.first_packet_time",
            "ip.last_packet_time",
            "ip.header_len",
            "ip.tot_len"
            ]

ipv6_event = [
            "meta.direction", # if = 0 then its client -> server (Checked with syn=1 ack=0)
            "ip.session_id",
            "time",
            "ip.version",
            "ip.src",
            "ip.dst",
            "ip.first_packet_time",
            "ip.last_packet_time"
            ]

def readMMTcsv(path):
    """
    Reads .csv report from MMT-probe, since the columns in .csv can have variable length it takes the maximal possible
    length.

    :param path: path to the .csv mmt probe report
    :return: DataFrame with all data from .csv
    """
    with open(path, 'r') as temp:
        col_count = [len(l.split(",")) for l in temp.readlines()]
        col_names = [i for i in range(0, max(col_count))]
        types_dict = {'0': int, '1': int, '2': "string", '3': 'float', '4': 'string'}
        types_dict.update({col: str for col in col_names if col not in types_dict})
        df = pd.read_csv(path, header=None, delimiter=",", names=col_names, dtype=types_dict)
        print("Read {} lines".format(df.shape[0]))
        return df


def extractReport(df, report_name):
    """
    Function extracting a proper dataframe with mmt-probe attributes about particular report (based on report_name).

    :param df: DataFrame with all data from .csv
    :param report_name: report to extract - possible values are in accordance with events predefined at the beginning of
    the script : (currently) tls_event, tcp_event, ipv4_event, ipv6_event
    :return:
    """
    new_df = df[df[4] == report_name].copy()
    # if report_name == "any-event":
    #     if not new_df.empty:
    #         new_df.columns = any_event  ##colnames from mmt-probe conf file
    #     else:
    #         new_df = pd.DataFrame(columns=any_event)
    if report_name == "ipv4-event":
        new_df.drop(columns=[0, 1, 2, 4],
                    inplace=True)  # ignoring 3 first columns (report id, ?, filepath) and 5th (report name)
        new_df.dropna(axis=1, inplace=True)
        # print(new_df)
        if not new_df.empty:
            new_df.columns = ipv4_event  ##colnames from mmt-probe conf file
        else:
            new_df = pd.DataFrame(columns=ipv4_event)

    elif report_name == "ipv6-event":
        new_df.drop(columns=[0, 1, 2, 4],
                    inplace=True)  # ignoring 3 first columns (report id, ?, filepath) and 5th (report name)
        new_df.dropna(axis=1, inplace=True)
        # print(new_df)
        if not new_df.empty:
            new_df.columns = ipv6_event  ##colnames from mmt-probe conf file
        else:
            new_df = pd.DataFrame(columns=ipv6_event)

    else:
        new_df.drop(columns=[0, 1, 2, 3, 4],
                    inplace=True)  # ignoring 3 first columns (report id, ?, time, filepath) and 5th (report name)
        new_df.dropna(axis=1, inplace=True)
        if report_name == "tcp-event":
            if not new_df.empty:
                new_df.columns = tcp_event  ##colnames from mmt-probe conf file
            else:
                new_df = pd.DataFrame(columns=tcp_event)
        elif report_name == "tls-event":
            if not new_df.empty:
                new_df.columns = tls_event  ##colnames from mmt-probe conf file
            else:
                new_df = pd.DataFrame(columns=tls_event)
    return new_df


def readAndExtractEvents(path):
    """
    Reads a .csv from MMT-probe, and extracts particular report into a separate dataframe - ipv4 and ipv6 are treated
    as one ip-event and merged into one dataframe (filled with 0 in case of lack of value)

    :param path: path to .csv created by MMT-probe
    :return: ip_traffic, tcp_traffic, tls_traffic - dataframes consisting of mmt-probe attributes from each of monitored events
    """
    df = readMMTcsv(path)

    # any_traffic = p1.extractReport("any-event")
    ipv4_traffic = extractReport(df, "ipv4-event")
    ipv6_traffic = extractReport(df, "ipv6-event")
    ip_traffic = ipv4_traffic.append(ipv6_traffic, sort=False)
    ip_traffic = ip_traffic.replace(np.nan, 0)
    tcp_traffic = extractReport(df, "tcp-event")
    tls_traffic = extractReport(df, "tls-event")
    df = df[0:0]

    return ip_traffic, tcp_traffic, tls_traffic


def trafficToFeatures(in_csv, out_pkl, is_malware=False):
    """
    Reads .csv, extracts set of mmt-probe attributes for each of the event and based on them calculates ML feaures
    (to one dataframe), adds additional column with label at the end of feature dataframe, and returns it in pkl form

    :param in_csv: mmt-probe report path
    :param out_pkl: path of pickle with dataframe consisting of calculated ML features
    :param is_malware: label to be added as last column to final dataframe determining if the traffic was normal (value 0)
    or malicious (value 1)
    :return: pickle with dataframe consisting of calculated ML features
    """
    if not os.path.isfile(out_pkl):
        ip_traffic, tcp_traffic, tls_traffic = readAndExtractEvents(in_csv)
        _, p1_features = calculateFeatures(ip_traffic, tcp_traffic, tls_traffic)
        p1_features = p1_features.fillna(0)
        if is_malware:
            p1_features['malware'] = 1
        else:
            p1_features['malware'] = 0

        print(p1_features.columns)
        p1_features.to_pickle(out_pkl)
        print("Extracted {} features".format(p1_features.shape[0]))
        p1_features = p1_features[0:0]
    else:
        print("Pkl {} already exists".format(out_pkl))


def eventsToFeatures(in_csv):
    """
    Based on .csv mmt-probe report extracts the report attributes, and calculates ML features.
    :param in_csv: input .csv report file
    :return: Dataframe of calculated ML features per flow and direction and IPs matching the flows
    """
    print("Convert from events to features {in_csv}")
    ip_traffic, tcp_traffic, tls_traffic = readAndExtractEvents(in_csv)
    ips, p1_features = calculateFeatures(ip_traffic, tcp_traffic, tls_traffic)
    p1_features = p1_features.fillna(0)
    print("Extracted {} features".format(p1_features.shape[0]))
    return ips, p1_features


def pickleAllFeatureFilesFromDir(in_path, out_path, is_malware=False):
    """
    Creates pickle files with ML features for all the mmt-probe .csv reports in the given folder

    :param in_path: folder with .csv reports
    :param out_path: folder where pickle files are to be written
    :param is_malware: label (normal 0 or malicious 1) to be added into dataframe in the pickle
    :return:
    """
    for i in os.listdir(in_path):
        print("Processing {}".format(i))
        trafficToFeatures(str(in_path + i), str(out_path + i + '.pkl'), is_malware)


def pickleFeatureFilesFromFile(in_file, out_file, is_malware=False):
    """
    Creates one pickle file with ML features for a single mmt-probe .csv report

    :param in_path: .csv mmt-probe report file
    :param out_path: pickle file to be saved
    :param is_malware: label (normal 0 or malicious 1) to be added into dataframe in the pickle
    :return:
    """
    print("Processing {}".format(in_file))
    trafficToFeatures(str(in_file), str(out_file + '.pkl'), is_malware)


def loadAllFeatureFilesFromPickleDir(path, max=1000):
    """
    Loads pickle files of dataframes with ML features from a path (Help function)
    :param path: folder with pickle files
    :param max: maximum number of files to read
    :return: a dataframe with appended all ML features read from (max) pickle files
    """
    features = pd.DataFrame()
    c = 0
    for i in os.listdir(path):
        if c >= max:
            return features
        else:
            features = features.append(pd.read_pickle(str(path + i)))
    return features

def loadFeaturesFromPickleFile(pathfile):
    """
    Loads a single pickle file of dataframes with ML features from a pickle file (Help function)
    :param path: pickle file
    :return: a dataframe with ML features
    """
    features = pd.DataFrame()
    features = features.append(pd.read_pickle(str(pathfile)))
    return features
